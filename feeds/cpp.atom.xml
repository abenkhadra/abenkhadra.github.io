<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Formally Applied - cpp</title><link href="https://blog.formallyapplied.com/" rel="alternate"></link><link href="https://blog.formallyapplied.com/feeds/cpp.atom.xml" rel="self"></link><id>https://blog.formallyapplied.com/</id><updated>2017-05-25T10:20:00+02:00</updated><entry><title>Undefined behavior in the wild</title><link href="https://blog.formallyapplied.com/2017/05/ub-in-wild/" rel="alternate"></link><published>2017-05-25T10:20:00+02:00</published><updated>2017-05-25T10:20:00+02:00</updated><author><name>Ammar Ben Khadra</name></author><id>tag:blog.formallyapplied.com,2017-05-25:/2017/05/ub-in-wild/</id><summary type="html">&lt;p class="first last"&gt;So I was hacking an open source C++ project. The project builds
using gcc v5.4 and runs without problems. Then, I grabbed gcc v6.2 to see
how much performance improvement can be gained. Surprisingly, the program segfaulted&amp;nbsp;&amp;#8230;&lt;/p&gt;
</summary><content type="html">&lt;p&gt;So I was hacking the code of an open source C++ project. The project builds
using gcc v5.4 and runs without problems. Then, I grabbed gcc v6.2 to see
how much performance improvement can it bring especially with its more updated &lt;span class="caps"&gt;LTO&lt;/span&gt;.
Expectedly, the project builds without problems. However, it failed at run-time
with a&amp;nbsp;segfault.&lt;/p&gt;
&lt;p&gt;Actually, such an error is usually a sign of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Undefined_behavior"&gt;Undefined Behavior&lt;/a&gt; (&lt;span class="caps"&gt;UB&lt;/span&gt;)
constructs that exists in the program. Specifically, a newer compiler (version) might be stricter
by rejecting programs that are perfectly acceptable by an older compiler.
However, such rejection should happen at compile time and not by causing unexpected errors at&amp;nbsp;run-time.&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;UB&lt;/span&gt; is a known concept in C/C++ which refers to operations that have no defined semantics
in the language specifications.
Therefore, compilers do not expect such operations to happen.
Basically, &lt;span class="caps"&gt;UB&lt;/span&gt; specifications constitute a &amp;#8220;contract&amp;#8221; that the developer needs to maintain.
In the case of violating this contract, the compiler is basically free
to do whatever it sees fit. This includes summoning &lt;a class="reference external" href="https://en.wiktionary.org/wiki/nasal_demon"&gt;nasal demons&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the following, I shall elaborate on this &lt;span class="caps"&gt;UB&lt;/span&gt; instance since it involves several interesting
C++ concepts. My discussion, while focusing on a particular &lt;span class="caps"&gt;UB&lt;/span&gt; instance, can provide
insights on the problems caused by &lt;span class="caps"&gt;UB&lt;/span&gt; in your code and how to avoid them.
For more details on &lt;span class="caps"&gt;UB&lt;/span&gt;, I recommend John Regehr&amp;#8217;s &lt;a class="reference external" href="http://blog.regehr.org/archives/213"&gt;blog series&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="identifying-the-problem"&gt;
&lt;h2&gt;Identifying the&amp;nbsp;problem&lt;/h2&gt;
&lt;p&gt;Consider the following code snippet which is a reduced version of the original &lt;span class="caps"&gt;UB&lt;/span&gt; instance.
The developer created the templated method &lt;code&gt;as&lt;/code&gt; (line 7) as a concise way to do
dynamic casting across the class hierarchy. The code &amp;#8220;works&amp;#8221; after compiling it
with gcc v5.4 or clang v4.8. Note that a nullptr check is in place (line 24) since
&lt;code&gt;snd_ptr&lt;/code&gt; is expected to be nullptr in case &lt;code&gt;fst_ptr&lt;/code&gt; was nullptr.
Interestingly, this snippet works even when compiled with gcc v6.2 with no optimizations (-O0).
However, it segfaults at line 22 when compiled with gcc v6.2 at optimization levels (-O1) or&amp;nbsp;higher.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fst_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;g++ 6.2 segfaults in the next statement&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;snd_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fst_ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Other compilers continue ... &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;snd_ptr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;snd_ptr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Let&amp;#8217;s now analyze this case a bit further. The root cause of the problem is setting
&lt;code&gt;fst_ptr&lt;/code&gt; to &lt;code&gt;nullptr&lt;/code&gt;. However, this should not cause a problem locating
method &lt;code&gt;as&lt;/code&gt; since it&amp;#8217;s a non-virtual method.
Remember that the compiler can emit direct calls for non-virtual methods at compile-time.
However, in the case of virtual methods, it needs to locate the &lt;cite&gt;vtable&lt;/cite&gt; of the object
instance at run-time. This would not be possible if the pointer to the object was&amp;nbsp;nullptr.&lt;/p&gt;
&lt;p&gt;Having checked that method &lt;code&gt;as&lt;/code&gt; is callable. We turn our attention to the dynamic
cast inside it (line 9). Passing a nullptr to &lt;code&gt;dynamic_cast&lt;/code&gt; is guaranteed
to return nullptr according to the C++ standard §5.2.7/4:
(thanks to this &lt;span class="caps"&gt;SO&lt;/span&gt; &lt;a class="reference external" href="https://stackoverflow.com/a/5155876"&gt;answer&lt;/a&gt;).
This suggests that in the case &lt;code&gt;this&lt;/code&gt; was nullptr, method &lt;code&gt;as&lt;/code&gt; must
return nullptr also. However, things are not that easy! Actually, setting &lt;code&gt;this&lt;/code&gt; to
nullptr is &lt;span class="caps"&gt;UB&lt;/span&gt;. It happens that gcc v6.2 did act upon this and produced a segfault
instead of calling &lt;code&gt;dynamic_cast&lt;/code&gt; on a nullptr as input.
Further, adding a check like &amp;#8220;if (this == nullptr)&amp;#8221; before dynamic casting
won&amp;#8217;t help either as compilers are free to optimize this&amp;nbsp;check.&lt;/p&gt;
&lt;p&gt;So we detected such a toy example of &lt;span class="caps"&gt;UB&lt;/span&gt; using manual analysis. This manual method
might work with smaller codebases. However, it is unlikely that it can scale to larger codebases
or more complex cases of &lt;span class="caps"&gt;UB&lt;/span&gt;. Fortunately, reasoning about &lt;span class="caps"&gt;UB&lt;/span&gt; has been largely
automated in recent years thanks to the &lt;span class="caps"&gt;UB&lt;/span&gt; sanitizers integrated into gcc and clang.
For example, we can compile the above snippet using the following&amp;nbsp;command,&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
g++ -std&lt;span class="o"&gt;=&lt;/span&gt;c++11 -Wall -Wextra -Wpedantic -fsanitize&lt;span class="o"&gt;=&lt;/span&gt;undefined ub.cpp -o ub.out
&lt;/pre&gt;
&lt;p&gt;Switching compiler flags to highest warning level is not critical here.
However, it is a recommended practice. Basically, we only need to pass the flag &lt;code&gt;-fsanitize=undefined&lt;/code&gt;
in order to activate the &lt;span class="caps"&gt;UB&lt;/span&gt; sanitizer.
Running the resulting executable &lt;code&gt;ub.out&lt;/code&gt;, would immediately produce suitable error messages
identifying the source of &lt;span class="caps"&gt;UB&lt;/span&gt; to be the call at line&amp;nbsp;22.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="possible-solutions"&gt;
&lt;h2&gt;Possible&amp;nbsp;solutions&lt;/h2&gt;
&lt;p&gt;After detecting the &lt;span class="caps"&gt;UB&lt;/span&gt; source, the question is how to fix it?
Well, as discussed previously, it&amp;#8217;s the responsibility of developers to avoid
&lt;span class="caps"&gt;UB&lt;/span&gt; in their code. Ideally, this means to ensure that &lt;span class="caps"&gt;UB&lt;/span&gt; never happens for &lt;em&gt;any&lt;/em&gt; program input.
In practice, however, we need to avoid unnecessary checks by ensuring that &lt;span class="caps"&gt;UB&lt;/span&gt; does not happen
on &amp;#8220;expected&amp;#8221; inputs - at&amp;nbsp;least.&lt;/p&gt;
&lt;p&gt;Translating this to our &lt;span class="caps"&gt;UB&lt;/span&gt; case, we can either (1) insert nullptr checks &lt;em&gt;before&lt;/em&gt; calling
method &lt;code&gt;as&lt;/code&gt;, (2) simply replace calls to method &lt;code&gt;as&lt;/code&gt; with dynamic casts,
or (3) convert method &lt;code&gt;as&lt;/code&gt; to be static. The last option requires the least amount
of change to the existing code which is a desirable property. Also,
it has the advantage of maintaining the type safety of the original code.
That is, method &lt;code&gt;as&lt;/code&gt; shall accept only class &lt;code&gt;Base&lt;/code&gt; or one of its derived classes as input.
The final code after applying solution (3) will look something like the&amp;nbsp;following,&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fst_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;snd_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fst_ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;snd_ptr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;snd_ptr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Finally, building portable and future-proof software in C/C++ requires paying
attention to &lt;span class="caps"&gt;UB&lt;/span&gt; in your code. The availability of excellent tool support in the
form of &lt;span class="caps"&gt;UB&lt;/span&gt; sanitizers, among others, has made catching &lt;span class="caps"&gt;UB&lt;/span&gt; significantly easier.
It&amp;#8217;s recommended to regularly activate &lt;span class="caps"&gt;UB&lt;/span&gt; sanitizers on your code
in order to catch potential issues early and more&amp;nbsp;often.&lt;/p&gt;
&lt;/div&gt;
</content><category term="c++"></category><category term="gcc"></category><category term="undefined behavior"></category></entry></feed>