<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Formally Applied</title><link href="https://blog.formallyapplied.com/" rel="alternate"></link><link href="https://blog.formallyapplied.com/feeds/all.atom.xml" rel="self"></link><id>https://blog.formallyapplied.com/</id><updated>2017-11-07T10:20:00+01:00</updated><entry><title>An introduction to approximate computing</title><link href="https://blog.formallyapplied.com/2017/11/approx-intro/" rel="alternate"></link><published>2017-11-07T10:20:00+01:00</published><updated>2017-11-07T10:20:00+01:00</updated><author><name>Ammar Ben Khadra</name></author><id>tag:blog.formallyapplied.com,2017-11-07:/2017/11/approx-intro/</id><summary type="html">&lt;p class="first last"&gt;Approximate computing is a wide spectrum of techniques that relax
accuracy of computations in order to improve performance, energy, and/or other
metric of merit. In this article, I&amp;#8217;ll try to provide a structured introduction
to this research&amp;nbsp;area.&lt;/p&gt;
</summary><content type="html">&lt;blockquote class="pull-quote"&gt;
&lt;p&gt;12 Dec 2017. This article is now available on &lt;a class="reference external" href="https://arxiv.org/abs/1711.06115"&gt;arXiv&lt;/a&gt; with more&amp;nbsp;updates.&lt;/p&gt;
&lt;p&gt;15 Nov 2017. General text&amp;nbsp;improvements.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Approximate Computing (&lt;span class="caps"&gt;AC&lt;/span&gt;) is a wide spectrum of techniques that relax
the accuracy of computation in order to improve performance, energy, and/or another
metric of merit.
&lt;span class="caps"&gt;AC&lt;/span&gt; exploits the fact that several important applications,
like machine learning and multimedia processing, do not require precise results to be&amp;nbsp;useful.&lt;/p&gt;
&lt;p&gt;For instance, we can use a lower resolution image encoder
in applications where high-quality images are not necessary.
In a data center, this may lead to large savings in
the amount of required processing, storage, and communication&amp;nbsp;bandwidth.&lt;/p&gt;
&lt;p&gt;Research interest in &lt;span class="caps"&gt;AC&lt;/span&gt; has been growing in recent years.
I refer here to two recent surveys &lt;a class="footnote-reference" href="#id17" id="id1"&gt;[1]&lt;/a&gt; &lt;a class="footnote-reference" href="#id18" id="id2"&gt;[2]&lt;/a&gt; for a comprehensive treatment.
In this article, I&amp;#8217;ll try to provide an introduction to this research&amp;nbsp;field.&lt;/p&gt;
&lt;p&gt;Basically, my discussion starts from the absolute beginning by motivating
&lt;span class="caps"&gt;AC&lt;/span&gt; and discussing its research scope.
Then, I discuss key concepts based on a proposed taxonomy.
Finally, I further elaborate on nondeterministic &lt;span class="caps"&gt;AC&lt;/span&gt;, an &lt;span class="caps"&gt;AC&lt;/span&gt; category with unique opportunities as well as&amp;nbsp;challenges.&lt;/p&gt;
&lt;p&gt;Graduate students will, hopefully, find this introduction useful
to catch up with recent&amp;nbsp;developments.&lt;/p&gt;
&lt;p&gt;Note that some of the ideas discussed here are based on a poster I presented at an &lt;span class="caps"&gt;AC&lt;/span&gt; workshop.
The workshop was a satellite event to &lt;a class="reference external" href="http://esweek.org/"&gt;&lt;span class="caps"&gt;ESWEEK&lt;/span&gt;&amp;#8216;16&lt;/a&gt;.
Our extended  &lt;a class="reference external" href="/docs/approx16.pdf"&gt;abstract&lt;/a&gt; highlighted some &lt;span class="caps"&gt;AC&lt;/span&gt; challenges and opportunities in general.
There, we argued that nondeterministic &lt;span class="caps"&gt;AC&lt;/span&gt; faces a fundamental
control-flow &lt;em&gt;wall&lt;/em&gt; which is bad news! The good news, however, is that there are
still enough opportunities in deterministic &lt;span class="caps"&gt;AC&lt;/span&gt; to keep practitioners busy for the foreseeable&amp;nbsp;future.&lt;/p&gt;
&lt;p&gt;I shall elaborate on those issues and more in the&amp;nbsp;following.&lt;/p&gt;
&lt;div class="section" id="motivation"&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;So let&amp;#8217;s start by trying to answer the &lt;em&gt;why&lt;/em&gt; and &lt;em&gt;what&lt;/em&gt; questions for &lt;span class="caps"&gt;AC&lt;/span&gt;.
Our concrete questions in this regard&amp;nbsp;are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;What motivates the recent academic interest in &lt;span class="caps"&gt;AC&lt;/span&gt;? In other words why do we
need to care about &lt;span class="caps"&gt;AC&lt;/span&gt; more than&amp;nbsp;before?&lt;/li&gt;
&lt;li&gt;What approximate computing really is? Note that &lt;span class="caps"&gt;AC&lt;/span&gt; is used in practice
for decades already, so what makes recent academic proposals&amp;nbsp;different?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In fact, research in &lt;span class="caps"&gt;AC&lt;/span&gt; can be motivated by two key concerns, namely, power and&amp;nbsp;reliability.&lt;/p&gt;
&lt;p&gt;Nowadays, the majority of our computations are being done either on mobile devices or in large data centers (think of cloud computing).
Both platforms are sensitive to power consumption.
That is, it would be nice if we can extend the operation time of smartphones and other battery powered devices
before the next&amp;nbsp;recharge.&lt;/p&gt;
&lt;p&gt;Also, and perhaps more importantly, the energy costs incurred
on data centers need to be reduced as much as possible. Note that power is one of (if not the) major
operational cost of running a data center. To this end, algorithmic optimizations,
dynamic run-time adaptation, and various types of hardware accelerators are used in&amp;nbsp;practice.&lt;/p&gt;
&lt;p&gt;Vector processors, FPGAs, GPUs, and even ASICs (like Google&amp;#8217;s recent &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Tensor_processing_unit"&gt;&lt;span class="caps"&gt;TPU&lt;/span&gt;&lt;/a&gt;)
are all being deployed in an orchestrated effort to optimize performance and reduce power&amp;nbsp;consumption.&lt;/p&gt;
&lt;p&gt;In this regard, the question that the &lt;span class="caps"&gt;AC&lt;/span&gt; community is trying to address is;
can we exploit the inherit approximate results of some application to gain more power&amp;nbsp;savings?&lt;/p&gt;
&lt;p&gt;We move now to reliability concerns to further motivate &lt;span class="caps"&gt;AC&lt;/span&gt;.
The semiconductor industry is aggressively improving it&amp;#8217;s production processes to keep
pace with the venerable Moore&amp;#8217;s law (or maybe a bit slower version of it in recent years).
Microchips produced with &lt;a class="reference external" href="https://en.wikipedia.org/wiki/10_nanometer"&gt;10 nanometer&lt;/a&gt;
processes are already shipping to production.
Moving toward 7 nanometers and beyond is expected within the next 5 years according
to the &lt;a class="reference external" href="http://www.itrs2.net/"&gt;&lt;span class="caps"&gt;ITRS&lt;/span&gt;&lt;/a&gt;&amp;nbsp;roadmap.&lt;/p&gt;
&lt;p&gt;Such nanometer regimes are expected to cause a twofold problem.
First, transistors can be more susceptible to faults (both temporary and permanent ones).
For example, cosmic radiation can more easily cause a glitch in data stored in a Flip-Flop.
Consequently, more investment might be necessary in hardware fault avoidance, detection, and&amp;nbsp;recovery.&lt;/p&gt;
&lt;p&gt;Second, feature variability between microchips or even across the same microchip
can also increase. This means that design margins need to be more pessimistic
to account for such large variability. That is, manufacturers have to allow for a wider margin
for the supply voltage, frequency, and other operational parameters in order to
keep the chip reliable while maintaining an economical&amp;nbsp;yield.&lt;/p&gt;
&lt;p&gt;In response to these reliability challenges, the &lt;span class="caps"&gt;AC&lt;/span&gt; community is investigating
the potential of using  narrower margins to operate microchips.
However, hardware faults might occasionally propagate to software in this case.
Therefore, the research goal is to ensure that such faults do not cause program outputs to diverge too much from the ideal&amp;nbsp;outputs.&lt;/p&gt;
&lt;p&gt;Such schemes can allow chip manufacturers to relax their investments in maintaining hardware reliability.
More performance and power saving opportunities can be harnessed by moving to best-effort hardware instead &lt;a class="footnote-reference" href="#id19" id="id3"&gt;[3]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="definition-and-scope"&gt;
&lt;h2&gt;Definition and&amp;nbsp;scope&lt;/h2&gt;
&lt;p&gt;So far, we motivated the need for approximate computing.
We move now to our second question; What is approximate computing in the first&amp;nbsp;place?&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s come back to our image encoding example. We know that applying any lossy compression
algorithm (&lt;span class="caps"&gt;JPEG&lt;/span&gt; for example) to a raw image will result in an approximate image.
Such compression often comes (by design) with little human perceptible loss in image quality.
Also, image encoders usually have tunable algorithmic &lt;em&gt;knobs&lt;/em&gt;, like compression level,
to trade off image size with its&amp;nbsp;quality.&lt;/p&gt;
&lt;p&gt;Therefore, do not we already know how to do &lt;span class="caps"&gt;AC&lt;/span&gt; on images?
Actually, instances of &lt;span class="caps"&gt;AC&lt;/span&gt; are by no means limited to image processing.
&lt;span class="caps"&gt;AC&lt;/span&gt; is visible in many domains from wireless communication to control systems and beyond.
In fact, one can argue that every computing system ever built did require balancing trade-offs
between cost and quality of results.
This is what engineering is about after&amp;nbsp;all.&lt;/p&gt;
&lt;p&gt;Indeed, approximate computing is already a stable tool in the engineering toolbox.
However, it&amp;#8217;s usually applied &lt;em&gt;manually&lt;/em&gt; leveraging domain knowledge and past experience.
The main goal of recent &lt;span class="caps"&gt;AC&lt;/span&gt; research, I think, is to introduce &lt;em&gt;automation&lt;/em&gt; to the approximation process.
That is, the research goal is to (semi-) automatically derive/synthesize more efficient computing systems
which produce approximate results that are good&amp;nbsp;enough.&lt;/p&gt;
&lt;p&gt;I shall elaborate on this point based on Figure (1).
Consider for example that you have been given a computing system with a well-specified functionality.
Such system can consist of software, hardware, or a combination of both.
Now, your task is to optimize this system to improve its performance.
How would you typically go about this&amp;nbsp;task?&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="manual vs. automatic approximate computing" src="/images/approx-fig01.png" /&gt;
&lt;p class="caption"&gt;Figure (1): &lt;span class="caps"&gt;AC&lt;/span&gt; can be applied (a) manually in the usual profile/optimize cycle,
or (b) automatically via an approximation method which may require providing an error quality&amp;nbsp;specification.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Ideally, you start by collecting &lt;em&gt;typical&lt;/em&gt; inputs which represent what you expect
the system to handle in the real world. Then, based on those inputs, you attempt to profile
the system to identify hot regions where the system spends most of the time.
After that, the serious optimization work begins which might involve several system&amp;nbsp;layers.&lt;/p&gt;
&lt;p&gt;For example, in a software program, you will often need to modify the algorithms and data structures used.
You might also go all the way down to the nitty-gritty details of improving cache alignment or
&amp;#8216;stealing&amp;#8217; unused bits in some data structures for other&amp;nbsp;purposes.&lt;/p&gt;
&lt;p&gt;This profile/optimize cycle continues until you either meet your performance target
or you think that you have reached the point of diminishing returns.
This optimization process is generally applicable to any computing system.
However, with a system that can tolerate &lt;em&gt;controllable&lt;/em&gt; deviations from its original outputs,
you can go a bit further in your&amp;nbsp;optimization.&lt;/p&gt;
&lt;p&gt;Basically, &lt;span class="caps"&gt;AC&lt;/span&gt; is about this last mile in optimization.
The research goal is to investigate &lt;strong&gt;automatic&lt;/strong&gt;, &lt;strong&gt;principled&lt;/strong&gt;, and ideally &lt;strong&gt;generic&lt;/strong&gt; techniques
to gain more efficiency by relaxing the exactness of outputs.
The need for automation is obvious since manual approximation techniques can simply be regarded as &amp;#8216;business as usual&amp;#8217;
i.e., without clear improvement over the state of&amp;nbsp;practice.&lt;/p&gt;
&lt;p&gt;Furthermore, &lt;span class="caps"&gt;AC&lt;/span&gt; needs to guarantee, in a principled way, that the expected output errors
will remain &amp;#8216;acceptable&amp;#8217; in the field.
That is, computing systems already struggle with implementation bugs. Therefore, it&amp;#8217;s difficult to adopt
an &lt;span class="caps"&gt;AC&lt;/span&gt; technique that can introduce more bugs in the form of arbitrary&amp;nbsp;outputs.&lt;/p&gt;
&lt;p&gt;We come to the third criterion which is generality.
I consider a technique to be generic if it is applicable to a wide spectrum of domains of interest to &lt;span class="caps"&gt;AC&lt;/span&gt;.
For example, loop invariant &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Loop-invariant_code_motion"&gt;code motion&lt;/a&gt;
is a generic compiler optimization that applies to virtually any program from scientific simulations
to &lt;a class="reference external" href="https://en.wikipedia.org/wiki/High-level_synthesis"&gt;high-level synthesis&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Generality, however, is more challenging to achieve in &lt;span class="caps"&gt;AC&lt;/span&gt; compared to the &amp;#8216;safe&amp;#8217; optimizations used in compilers.
A &lt;em&gt;local&lt;/em&gt; &lt;span class="caps"&gt;AC&lt;/span&gt; optimization might introduce errors which are difficult to reason about when combined
with other &lt;em&gt;local&lt;/em&gt; optimizations.
Note that the combined error observed on the &lt;em&gt;global&lt;/em&gt; outputs might be composed of several local&amp;nbsp;errors.&lt;/p&gt;
&lt;p&gt;Actually, I&amp;#8217;d argue that it&amp;#8217;s not feasible to target, to a satisfactory level, all three criteria.
In other words, better automation and principled guarantees require compromising on generality.
This can be achieved by embedding domain-specific knowledge in the &lt;span class="caps"&gt;AC&lt;/span&gt; technique.
This seems to be a reasonable thing to do given the diversity of domains where &lt;span class="caps"&gt;AC&lt;/span&gt; is&amp;nbsp;applicable.&lt;/p&gt;
&lt;p&gt;A prime advantage of compromising on generality is that end users won&amp;#8217;t need to explicitly
provide error quality specification, see Figure (1).
Metrics of acceptable errors will be based on the specific domain.
For instance, &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Generalization_error"&gt;generalization error&lt;/a&gt; in machine learning and
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio"&gt;&lt;span class="caps"&gt;PSNR&lt;/span&gt;&lt;/a&gt; in image&amp;nbsp;compression.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-taxonomy-of-approximate-computing"&gt;
&lt;h2&gt;A taxonomy of approximate&amp;nbsp;computing&lt;/h2&gt;
&lt;p&gt;The literature on approximate computing is large and growing.
Also, it covers the entire system stack from high-level algorithms down to individual hardware circuits.
It&amp;#8217;s difficult to make sense of all of these developments without introducing some sort of structure.
In this section, I&amp;#8217;ll attempt such structuring based on the taxonomy depicted in Figure (2).
Also, selected pointers to the relevant literature will be&amp;nbsp;highlighted.&lt;/p&gt;
&lt;p&gt;Basically, my hypothesis is that we can map any individual &lt;span class="caps"&gt;AC&lt;/span&gt; technique to a point in a
three-dimensional space. The considered axes represent the approximation level,
required run-time support, and behavior determinism respectively.
Of course, there are papers on &lt;span class="caps"&gt;AC&lt;/span&gt; that combine several techniques in one&amp;nbsp;proposal.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="approximate computing taxonomy" src="/images/approx-fig02.png" /&gt;
&lt;p class="caption"&gt;Figure (2): Proposed &lt;span class="caps"&gt;AC&lt;/span&gt; taxonomy. Expected cost of targeting a design point
rises as we move away from the&amp;nbsp;center.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The reader might be wondering why hardware circuits have been placed higher up while
the algorithm level is at the bottom? The reason is simply the expected &lt;em&gt;cost&lt;/em&gt; of targeting
such a design point. In other words, I expect the implementation cost to increase
as one explores design points further away from the&amp;nbsp;center.&lt;/p&gt;
&lt;p&gt;For instance, a system that involves dynamic run-time adaption, e.g., for error quality monitoring,
is more complex, and thus more costly, to build and maintain compared to a static system.
However, run-time adaptation might provide sufficient benefits to amortize the higher cost if designed with&amp;nbsp;care.&lt;/p&gt;
&lt;p&gt;Now, we move to the determinism axis.
My classification is based on the usual &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm"&gt;determinism&lt;/a&gt; property.
That is, an algorithm that returns the same output repeatedly given the same input is &lt;em&gt;deterministic&lt;/em&gt;.
Nondeterministic algorithms do not exhibit such output&amp;nbsp;repeatability.&lt;/p&gt;
&lt;p&gt;I further classify nondeterministic algorithms to &lt;em&gt;partially&lt;/em&gt; and &lt;em&gt;fully&lt;/em&gt; nondeterministic.
These categories are based on the sources of nondeterminism in the algorithm and bug reproducibility.
Nondeterministic &lt;span class="caps"&gt;AC&lt;/span&gt; will be discussed in more detail in the next&amp;nbsp;section.&lt;/p&gt;
&lt;p&gt;The axis of approximation level in Figure (2) has been (roughly) divided into 4 categories.
At algorithm level, a given algorithm is kept intact.
To implement approximation, one has to manipulate either the inputs or algorithm configurations
(knobs or &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Hyperparameter_(machine_learning)"&gt;hyperparameters&lt;/a&gt;).
An example of the former can be found in ApproxHadoop &lt;a class="footnote-reference" href="#id20" id="id4"&gt;[4]&lt;/a&gt; where the authors utilized a statistical input
sampling scheme in order to derive approximate&amp;nbsp;results.&lt;/p&gt;
&lt;p&gt;In comparison, one can leave the inputs and modify the hyperparameters instead.
Approximation via hyperparameter
optimization is a well-established research theme in machine learning. It&amp;#8217;s known there as &amp;#8216;learning to learn&amp;#8217;
or &amp;#8216;meta-learning&amp;#8217;. I won&amp;#8217;t elaborate on this here and refer the reader to &lt;a class="footnote-reference" href="#id21" id="id5"&gt;[5]&lt;/a&gt;
simply because the paper title seems &amp;#8216;meta&amp;#8217;&amp;nbsp;enough.&lt;/p&gt;
&lt;p&gt;Also noteworthy in the algorithm category is Capri &lt;a class="footnote-reference" href="#id22" id="id6"&gt;[6]&lt;/a&gt;.
There, the authors formulate knob tuning as a constrained optimization problem.
To solve this problem, their proposed system learns cost and error models using bayesian&amp;nbsp;networks.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s move now to application level approximation where we have to
modify things &lt;em&gt;inside&lt;/em&gt; the original algorithm. Compare this to the previous level
where the original algorithm was an untouchable black-box.
A good example here is loop perforation &lt;a class="footnote-reference" href="#id23" id="id7"&gt;[7]&lt;/a&gt;.
There, the authors identified certain loop patterns and propose techniques to automatically skip
loop&amp;nbsp;iterations.&lt;/p&gt;
&lt;p&gt;For approximation at the architecture level, I refer to Quora &lt;a class="footnote-reference" href="#id24" id="id8"&gt;[8]&lt;/a&gt;.
Basically, the authors propose to extend the &lt;span class="caps"&gt;ISA&lt;/span&gt; of vector processors such
that computation quality can be specified in the instruction set.
Error precision is deterministically bound for each&amp;nbsp;instruction.&lt;/p&gt;
&lt;p&gt;Finally, there is approximation in hardware circuits.
There are several proposals in the literature for approximate arithmetic units like
adders and multipliers. They can be generally classified to deterministic
(with reduced precision) and nondeterministic. Units of the latter type work most of
the time as expected. However, they can occasionally produce arbitrary&amp;nbsp;outputs.&lt;/p&gt;
&lt;p&gt;The approximate circuits previously discussed are mostly designed manually for their specific purpose.
In contrast, the authors of &lt;span class="caps"&gt;SALSA&lt;/span&gt; &lt;a class="footnote-reference" href="#id25" id="id9"&gt;[9]&lt;/a&gt; approach hardware approximation from a different angle.
They propose a general technique to &lt;em&gt;automatically&lt;/em&gt; synthesize approximate circuits given golden &lt;span class="caps"&gt;RTL&lt;/span&gt; model and quality&amp;nbsp;specifications.&lt;/p&gt;
&lt;p&gt;I conclude this section by discussing how cost is expected to increase as we go from algorithm level to circuit
level. Given a (correct) algorithm that exposes some configurable knobs. Adapting such algorithm
to different settings is relatively cheap. Also, it can be highly automated based on established meta-
optimization literature as can be found in&amp;nbsp;meta-learning.&lt;/p&gt;
&lt;p&gt;However, things get more challenging if we were to approximate outputs based on the internal workings of an algorithm.
Generally, this application level approximation requires asking users for annotations or assumptions on expected inputs.
Consequently, there is a smaller opportunity for automation and more difficulty in guaranteeing error&amp;nbsp;quality.&lt;/p&gt;
&lt;p&gt;The expected cost gets even higher at architecture level were several stakeholders might be affected.
Compiler engineers, operating systems developers, and hardware architects all need to be either
directly involved or at least aware of the approximation intended by the original algorithm developers.
A proposed &lt;span class="caps"&gt;AC&lt;/span&gt; technique should demonstrate a serious value across the board to convince all of these
people to get&amp;nbsp;involved.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="on-nondeterministic-approximate-computing"&gt;
&lt;h2&gt;On nondeterministic approximate&amp;nbsp;computing&lt;/h2&gt;
&lt;p&gt;Let&amp;#8217;s begin this section with a definition;
An algorithm is considered to be nondeterministic if its output can be different for the same input.
In a partially nondeterministic algorithm, nondeterminism sources can be feasibly accounted for a priori.
Otherwise, the algorithm is considered fully&amp;nbsp;nondeterministic.&lt;/p&gt;
&lt;p&gt;Simulated annealing is an example of a partially nondeterministic algorithm where
picking the next step is based on a random choice.
Despite this, its control-flow behavior remain predictable which makes it relatively
easy to reproduce implementation bugs with repeated runs.
In contrast, the followed control-flow path can differ in &amp;#8216;unexpected&amp;#8217; ways
in the case of fully nondeterministic&amp;nbsp;algorithms.&lt;/p&gt;
&lt;p&gt;A nondeterministic &lt;span class="caps"&gt;AC&lt;/span&gt; technique introduces (or increases) nondeterminism in a given
algorithm. This can be realized in several ways.
In ApproxHadoop, the authors proposed random task dropping to gain more efficiency. Also, authors of &lt;span class="caps"&gt;SAGE&lt;/span&gt; &lt;a class="footnote-reference" href="#id26" id="id10"&gt;[10]&lt;/a&gt;
proposed skipping atomic primitives to gain performance at the expense of
exposing the algorithm to race&amp;nbsp;conditions.&lt;/p&gt;
&lt;p&gt;Nondeterministic &lt;span class="caps"&gt;AC&lt;/span&gt; introduced by unreliable hardware has
received special attention from the research community. This is motivated
by the potential efficiency gains discussed already.
I&amp;#8217;ll focus in the following on nondeterministic &lt;span class="caps"&gt;AC&lt;/span&gt; that is realized by unreliable hardware.
Note that an algorithm is, typically, fully nondeterministic in this&amp;nbsp;case.&lt;/p&gt;
&lt;p&gt;There several possibilities to implement hardware-based nondeterministic &lt;span class="caps"&gt;AC&lt;/span&gt;.
&lt;span class="caps"&gt;DRAM&lt;/span&gt; cells need a periodic refresh to retain their data which consumes energy.
Equipping DRAMs with &amp;#8216;selective&amp;#8217; no-refresh mechanisms saves energy but risks occasional bit&amp;nbsp;errors.&lt;/p&gt;
&lt;p&gt;Similarly, dynamically adapting bus compression and error detection mechanisms can provide  significant
gains in the communication between main memory and processing&amp;nbsp;cores.&lt;/p&gt;
&lt;p&gt;Additionally, there are efficiency opportunities in allowing processing cores
themselves to provide a best-effort rather than a reliable service.
In this setting, hardware engineers may &lt;em&gt;optimistically&lt;/em&gt; invest in reliability&amp;nbsp;mechanisms.&lt;/p&gt;
&lt;p&gt;However, software programmers need, in turn, to be aware of hardware unreliability and
invest in fault management schemes suitable for their particular needs.
Relax &lt;a class="footnote-reference" href="#id27" id="id11"&gt;[11]&lt;/a&gt; provide a good example of such an&amp;nbsp;arrangement.&lt;/p&gt;
&lt;p&gt;Also, &lt;span class="caps"&gt;CLEAR&lt;/span&gt; &lt;a class="footnote-reference" href="#id28" id="id12"&gt;[12]&lt;/a&gt; provides an interesting design-space exploration
of reliability against soft-errors across the entire system&amp;nbsp;stack.&lt;/p&gt;
&lt;p&gt;Despite the extensive research in reliability in general and more recently
in &lt;span class="caps"&gt;AC&lt;/span&gt;. The problem of running software &lt;em&gt;reliably&lt;/em&gt; and &lt;em&gt;efficiently&lt;/em&gt;
on unreliable hardware is far from solved.
Beside the cost factor mentioned in the previous section,
there are still major interdisciplinary problems to be&amp;nbsp;addressed.&lt;/p&gt;
&lt;p&gt;First, there is the abstraction problem of the hardware/software interface.
Extending the &lt;span class="caps"&gt;ISA&lt;/span&gt; abstraction makes sense given its ubiquity.
For example, each &lt;span class="caps"&gt;ISA&lt;/span&gt; instruction might be extended with probability specification.
This probability quantifies how many times this nondeterministic instruction is expected to
supply correct results (I&amp;#8217;m becoming frequentist&amp;nbsp;here).&lt;/p&gt;
&lt;p&gt;However, microchip designs nowadays are complex possibly comprising tens of &lt;span class="caps"&gt;IP&lt;/span&gt; modules
from several &lt;span class="caps"&gt;IP&lt;/span&gt; providers. It&amp;#8217;s difficult for a microchip manufacturer to derive such
probabilities per individual instruction.
Even where such derivation is possible,
microchip manufacturers would be reluctant to guarantee such probabilities
to their customers. Maintaining such guarantees through the entire product lifetime
would prove&amp;nbsp;costly.&lt;/p&gt;
&lt;p&gt;Further, I think that it&amp;#8217;s still not clear how much value can this instruction-level abstraction
provide to hardware as well as software engineers.
Consequently, the question of finding suitable and generic abstractions between software and unreliable hardware is still&amp;nbsp;open.&lt;/p&gt;
&lt;p&gt;Second, there is the correctness challenge.
Can we establish that a software running on nondeterministic hardware is correct
or maybe &lt;a class="reference external" href="https://www.cs.cornell.edu/~asampson/blog/probablycorrect.html"&gt;probably correct&lt;/a&gt;?
A short answer is probably&amp;nbsp;no!&lt;/p&gt;
&lt;p&gt;There are several reasons for this correctness challenge.
Statistical correctness requires sampling from (joint) probability distributions of inputs
which are typically not available a priori.
Also, software functions are generally noncontinuous and nonlinear in the mathematical sense.
This makes them good at hiding unexpected behaviors in the&amp;nbsp;corners.&lt;/p&gt;
&lt;p&gt;More importantly, algorithms process inputs in deterministic steps based on a
specific control-flow. Nondeterministic hardware might affect control-flow decisions
causing the algorithm to immediately fail, or worse, proceed and produce arbitrary&amp;nbsp;outputs.&lt;/p&gt;
&lt;p&gt;Note that the focus of this discussion is on the setting of a single computing node.
Fault-tolerance in distributed systems consisting of many nodes is quite different.
Although, the latter might be affected if individual nodes continue behaving unpredictably instead
of just &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Fail-fast"&gt;failing fast&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let me elaborate based on the following code snippet. The function &lt;code&gt;approximate&lt;/code&gt;
takes two inputs &lt;code&gt;i1&lt;/code&gt; and &lt;code&gt;i2&lt;/code&gt; and one hyperparameter input &lt;code&gt;i3&lt;/code&gt;.
The latter is assumed to be a positive integer.
Local parameter &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;i3&lt;/code&gt;
need to be protected (e.g., using software redundancy) otherwise the loop might not&amp;nbsp;terminate.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;approximate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;i3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
      &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;The question now is what shall we do with functions &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;.
Leaving them unprotected means that we risk producing unpredictable value in &lt;code&gt;result&lt;/code&gt;.
Note that a control-flow decision at line #4 is based on them.
This should provide a good reason for protecting&amp;nbsp;them.&lt;/p&gt;
&lt;p&gt;On the other hand, protecting &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; with software-based reliability
can prove more costly than running function &lt;code&gt;approximate&lt;/code&gt; on deterministic hardware in the first place.
This is the essence of the control-flow&amp;nbsp;wall.&lt;/p&gt;
&lt;p&gt;Basically, decisions taken in the control-flow usually depend on the processed data.
Guaranteeing data correctness is costly to do in software.
On the other hand, allowing nondeterministic errors to affect data means that we can&amp;#8217;t, in general, guarantee how the algorithm would&amp;nbsp;behave.&lt;/p&gt;
&lt;p&gt;General-purpose programming on nondeterministic hardware was tackled in Chisel &lt;a class="footnote-reference" href="#id29" id="id13"&gt;[13]&lt;/a&gt;
(A successor for a language called Rely).
The authors assume a hardware model where processors provide reliable and unreliable
versions of instructions. Also, data can be stored in an unreliable&amp;nbsp;memory.&lt;/p&gt;
&lt;p&gt;There, developers are expected to provide reliability specifications.
Also, hardware engineers need to provide approximation specification.
The authors combine static analysis and Integer-Linear Programming in
order explore the design-space while maintaining the validity of reliability specification.
Still, their analyses are limited by data dependencies in the control-flow&amp;nbsp;graph.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s important to differentiate between the reliability specification in Chisel
and the similar probabilistic specification of say Uncertain&amp;lt;T&amp;gt; &lt;a class="footnote-reference" href="#id30" id="id14"&gt;[14]&lt;/a&gt;.
The latter is a probabilistic programming extension to general-purpose languages.
This means that the inputs are, typically, prior probability distributions that need to
be processed &lt;em&gt;deterministically&lt;/em&gt;&amp;nbsp;.&lt;/p&gt;
&lt;p&gt;That said, and without being able to guarantee (probable) correctness,
would it make any sense to use nondeterministic hardware? Well, it depends.
In the case where the cost of failure is small, and errors can&amp;#8217;t propagate deep into the program
anyway, being failure oblivious might make sense &lt;a class="footnote-reference" href="#id31" id="id15"&gt;[15]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Also, heterogeneous reliability, from my perspective, can make nondeterministic
hardware a viable option in practice.
Basically, reliable cores are used to run operating systems, language runtime, and programs.
Only compute-intensive kernels/regions might be offloaded to accelerators which are possibly built using unreliable nondeterministic hardware.
A notable example here is &lt;span class="caps"&gt;ERSA&lt;/span&gt; &lt;a class="footnote-reference" href="#id32" id="id16"&gt;[16]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Improving efficiency is a continuous endeavor in all engineering disciplines.
This endeavor requires balancing trade-offs between system cost and gained value.
The goal is to obtain results that are good enough for the cost we&amp;nbsp;invest.&lt;/p&gt;
&lt;p&gt;Approximate computing is the research area where we attempt to realize techniques to
&lt;em&gt;automatically&lt;/em&gt; gain computing efficiency by trading off output quality with a metric of interest
such as performance and energy.
Automation is key to the value proposal of approximate computing as practitioners
are able of manually balancing those trade-offs&amp;nbsp;already.&lt;/p&gt;
&lt;p&gt;Approximation also needs to be &lt;em&gt;principled&lt;/em&gt; which allow practitioners to
trust the system to behave as expected in the real world.
Combining automation and principled guarantees is essential, in my opinion,
for approximate computing to have a secure place in the engineering&amp;nbsp;toolbox.&lt;/p&gt;
&lt;p&gt;This article briefly introduced approximate computing.
The discussion covered the entire system stack from algorithms to hardware circuits.
Also, I elaborated a bit on nondeterministic approximation computing due to
the special attention it received from the research&amp;nbsp;community.&lt;/p&gt;
&lt;p&gt;&lt;span class="raw-html"&gt;&lt;hr/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id17" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[1]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;S.&lt;/tt&gt; Mittal, “A Survey of Techniques for Approximate Computing,” &lt;span class="caps"&gt;ACM&lt;/span&gt; Comput. Surv., vol. 48, no. 4, pp. 1–33, Mar. 2016.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id18" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[2]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;Q.&lt;/tt&gt; Xu, et al. “Approximate Computing: A Survey,” &lt;span class="caps"&gt;IEEE&lt;/span&gt; Des. Test, vol. 33, no. 1, pp. 8–22, Feb. 2016.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id19" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[3]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;S.&lt;/tt&gt; Chakradhar and A. Raghunathan, “Best-effort computing: Re-thinking Parallel Software and Hardware,” in Proceedings of the 47th Design Automation Conference (&lt;span class="caps"&gt;DAC&lt;/span&gt; ’10), 2010, p. 865.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id20" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[4]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;I.&lt;/tt&gt; Goiri, et al. “ApproxHadoop: Bringing Approximations to MapReduce Frameworks,” in Proceedings of the 20th International Conference on Architectural Support for Programming Languages and Operating Systems (&lt;span class="caps"&gt;ASPLOS&lt;/span&gt;’15), 2015, vol. 43, no. 1, pp. 383–397.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id21" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[5]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;M.&lt;/tt&gt; Andrychowicz, et al., “Learning to learn by gradient descent by gradient descent,” preprint arXiv:1606.04474, 2016.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id22" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[6]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;X.&lt;/tt&gt; Sui, A. Lenharth, &lt;span class="caps"&gt;D. S.&lt;/span&gt; Fussell, and K. Pingali, “Proactive Control of Approximate Programs,” in Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems (&lt;span class="caps"&gt;ASPLOS&lt;/span&gt; ’16), 2016, pp. 607–621.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id23" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[7]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;S.&lt;/tt&gt; Sidiroglou-Douskos, et al. “Managing performance vs. accuracy trade-offs with loop perforation,” in Proceedings of the 19th &lt;span class="caps"&gt;ACM&lt;/span&gt; &lt;span class="caps"&gt;SIGSOFT&lt;/span&gt; symposium and the 13th European conference on Foundations of software engineering (&lt;span class="caps"&gt;FSE&lt;/span&gt;’11), 2011, pp. 124–134.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id24" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[8]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;S.&lt;/tt&gt; Venkataramani, et al. “Quality programmable vector processors for approximate computing,” in Proceedings of the 46th Annual &lt;span class="caps"&gt;IEEE&lt;/span&gt;/&lt;span class="caps"&gt;ACM&lt;/span&gt; International Symposium on Microarchitecture - &lt;span class="caps"&gt;MICRO&lt;/span&gt;-46, 2013, pp. 1–12.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id25" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[9]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;S.&lt;/tt&gt; Venkataramani, et al. “&lt;span class="caps"&gt;SALSA&lt;/span&gt;: Systematic logic synthesis of approximate circuits,” in Proceedings of the 49th Annual Design Automation Conference on - &lt;span class="caps"&gt;DAC&lt;/span&gt; ’12, 2012, pp. 796–801.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id26" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[10]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;M.&lt;/tt&gt; Samadi, et al. “&lt;span class="caps"&gt;SAGE&lt;/span&gt;: self-tuning approximation for graphics engines,” in Proceedings of the 46th Annual &lt;span class="caps"&gt;IEEE&lt;/span&gt;/&lt;span class="caps"&gt;ACM&lt;/span&gt; International Symposium on Microarchitecture (&lt;span class="caps"&gt;MICRO&lt;/span&gt;&amp;#8216;46), 2013, pp. 13–24.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id27" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[11]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;M.&lt;/tt&gt; de Kruijf, et al. “Relax: an architectural framework for software recovery of hardware faults,” in Proceedings of the 37th annual international symposium on Computer architecture, 2010, pp. 497–508.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id28" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[12]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;E.&lt;/tt&gt; Cheng, et al. “&lt;span class="caps"&gt;CLEAR&lt;/span&gt;: Cross-Layer Exploration for Architecting Resilience: Combining Hardware and Software Techniques To Tolerate Soft Errors in Processor Cores,” in Proceedings of the 53rd Annual Design Automation Conference (&lt;span class="caps"&gt;DAC&lt;/span&gt;’16), 2016, p. 68.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id29" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[13]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;S.&lt;/tt&gt; Misailovic, et al. “Chisel: reliability- and accuracy-aware optimization of approximate computational kernels,” in Proceedings of the 2014 &lt;span class="caps"&gt;ACM&lt;/span&gt; International Conference on Object Oriented Programming Systems Languages &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; Applications (&lt;span class="caps"&gt;OOPSLA&lt;/span&gt;’14), 2014, pp. 309–328.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id30" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[14]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;J.&lt;/tt&gt; Bornholt, et al. “Uncertain&amp;lt; T &amp;gt;: a first-order type for uncertain data,” in Proceedings of the 19th international conference on Architectural support for programming languages and operating systems, 2014, pp. 51–66.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id31" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[15]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;M.&lt;/tt&gt; Rinard, et al. “Enhancing server availability and security through failure-oblivious computing,” in Proceedings of the 6th conference on Symposium on Opearting Systems Design &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; Implementation (&lt;span class="caps"&gt;OSDI&lt;/span&gt;’04), 2004, p. 21.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id32" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[16]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;L.&lt;/tt&gt; Leem, et al. “&lt;span class="caps"&gt;ERSA&lt;/span&gt;: Error Resilient System Architecture for Probabilistic Applications,” in Proceedings of the Conference on Design, Automation and Test in Europe (&lt;span class="caps"&gt;DATE&lt;/span&gt;&amp;#8216;10), 2010, pp. 1560–1565.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="approximate computing"></category><category term="reliability"></category></entry><entry><title>Undefined behavior in the wild</title><link href="https://blog.formallyapplied.com/2017/05/ub-in-wild/" rel="alternate"></link><published>2017-05-25T10:20:00+02:00</published><updated>2017-05-25T10:20:00+02:00</updated><author><name>Ammar Ben Khadra</name></author><id>tag:blog.formallyapplied.com,2017-05-25:/2017/05/ub-in-wild/</id><summary type="html">&lt;p class="first last"&gt;So I was hacking an open source C++ project. The project builds
using gcc v5.4 and runs without problems. Then, I grabbed gcc v6.2 to see
how much performance improvement can be gained. Surprisingly, the program segfaulted&amp;nbsp;&amp;#8230;&lt;/p&gt;
</summary><content type="html">&lt;p&gt;So I was hacking the code of an open source C++ project. The project builds
using gcc v5.4 and runs without problems. Then, I grabbed gcc v6.2 to see
how much performance improvement can it bring especially with its more updated &lt;span class="caps"&gt;LTO&lt;/span&gt;.
Expectedly, the project builds without problems. However, it failed at run-time
with a&amp;nbsp;segfault.&lt;/p&gt;
&lt;p&gt;Actually, such an error is usually a sign of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Undefined_behavior"&gt;Undefined Behavior&lt;/a&gt; (&lt;span class="caps"&gt;UB&lt;/span&gt;)
constructs that exists in the program. Specifically, a newer compiler (version) might be stricter
by rejecting programs that are perfectly acceptable by an older compiler.
However, such rejection should happen at compile time and not by causing unexpected errors at&amp;nbsp;run-time.&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;UB&lt;/span&gt; is a known concept in C/C++ which refers to operations that have no defined semantics
in the language specifications.
Therefore, compilers do not expect such operations to happen.
Basically, &lt;span class="caps"&gt;UB&lt;/span&gt; specifications constitute a &amp;#8220;contract&amp;#8221; that the developer needs to maintain.
In the case of violating this contract, the compiler is basically free
to do whatever it sees fit. This includes summoning &lt;a class="reference external" href="https://en.wiktionary.org/wiki/nasal_demon"&gt;nasal demons&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the following, I shall elaborate on this &lt;span class="caps"&gt;UB&lt;/span&gt; instance since it involves several interesting
C++ concepts. My discussion, while focusing on a particular &lt;span class="caps"&gt;UB&lt;/span&gt; instance, can provide
insights on the problems caused by &lt;span class="caps"&gt;UB&lt;/span&gt; in your code and how to avoid them.
For more details on &lt;span class="caps"&gt;UB&lt;/span&gt;, I recommend John Regehr&amp;#8217;s &lt;a class="reference external" href="http://blog.regehr.org/archives/213"&gt;blog series&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="identifying-the-problem"&gt;
&lt;h2&gt;Identifying the&amp;nbsp;problem&lt;/h2&gt;
&lt;p&gt;Consider the following code snippet which is a reduced version of the original &lt;span class="caps"&gt;UB&lt;/span&gt; instance.
The developer created the templated method &lt;code&gt;as&lt;/code&gt; (line 7) as a concise way to do
dynamic casting across the class hierarchy. The code &amp;#8220;works&amp;#8221; after compiling it
with gcc v5.4 or clang v4.8. Note that a nullptr check is in place (line 24) since
&lt;code&gt;snd_ptr&lt;/code&gt; is expected to be nullptr in case &lt;code&gt;fst_ptr&lt;/code&gt; was nullptr.
Interestingly, this snippet works even when compiled with gcc v6.2 with no optimizations (-O0).
However, it segfaults at line 22 when compiled with gcc v6.2 at optimization levels (-O1) or&amp;nbsp;higher.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fst_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;g++ 6.2 segfaults in the next statement&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;snd_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fst_ptr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Other compilers continue ... &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;snd_ptr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;snd_ptr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Let&amp;#8217;s now analyze this case a bit further. The root cause of the problem is setting
&lt;code&gt;fst_ptr&lt;/code&gt; to &lt;code&gt;nullptr&lt;/code&gt;. However, this should not cause a problem locating
method &lt;code&gt;as&lt;/code&gt; since it&amp;#8217;s a non-virtual method.
Remember that the compiler can emit direct calls for non-virtual methods at compile-time.
However, in the case of virtual methods, it needs to locate the &lt;cite&gt;vtable&lt;/cite&gt; of the object
instance at run-time. This would not be possible if the pointer to the object was&amp;nbsp;nullptr.&lt;/p&gt;
&lt;p&gt;Having checked that method &lt;code&gt;as&lt;/code&gt; is callable. We turn our attention to the dynamic
cast inside it (line 9). Passing a nullptr to &lt;code&gt;dynamic_cast&lt;/code&gt; is guaranteed
to return nullptr according to the C++ standard §5.2.7/4:
(thanks to this &lt;span class="caps"&gt;SO&lt;/span&gt; &lt;a class="reference external" href="https://stackoverflow.com/a/5155876"&gt;answer&lt;/a&gt;).
This suggests that in the case &lt;code&gt;this&lt;/code&gt; was nullptr, method &lt;code&gt;as&lt;/code&gt; must
return nullptr also. However, things are not that easy! Actually, setting &lt;code&gt;this&lt;/code&gt; to
nullptr is &lt;span class="caps"&gt;UB&lt;/span&gt;. It happens that gcc v6.2 did act upon this and produced a segfault
instead of calling &lt;code&gt;dynamic_cast&lt;/code&gt; on a nullptr as input.
Further, adding a check like &amp;#8220;if (this == nullptr)&amp;#8221; before dynamic casting
won&amp;#8217;t help either as compilers are free to optimize this&amp;nbsp;check.&lt;/p&gt;
&lt;p&gt;So we detected such a toy example of &lt;span class="caps"&gt;UB&lt;/span&gt; using manual analysis. This manual method
might work with smaller codebases. However, it is unlikely that it can scale to larger codebases
or more complex cases of &lt;span class="caps"&gt;UB&lt;/span&gt;. Fortunately, reasoning about &lt;span class="caps"&gt;UB&lt;/span&gt; has been largely
automated in recent years thanks to the &lt;span class="caps"&gt;UB&lt;/span&gt; sanitizers integrated into gcc and clang.
For example, we can compile the above snippet using the following&amp;nbsp;command,&lt;/p&gt;
&lt;pre class="code bash literal-block"&gt;
g++ -std&lt;span class="o"&gt;=&lt;/span&gt;c++11 -Wall -Wextra -Wpedantic -fsanitize&lt;span class="o"&gt;=&lt;/span&gt;undefined ub.cpp -o ub.out
&lt;/pre&gt;
&lt;p&gt;Switching compiler flags to highest warning level is not critical here.
However, it is a recommended practice. Basically, we only need to pass the flag &lt;code&gt;-fsanitize=undefined&lt;/code&gt;
in order to activate the &lt;span class="caps"&gt;UB&lt;/span&gt; sanitizer.
Running the resulting executable &lt;code&gt;ub.out&lt;/code&gt;, would immediately produce suitable error messages
identifying the source of &lt;span class="caps"&gt;UB&lt;/span&gt; to be the call at line&amp;nbsp;22.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="possible-solutions"&gt;
&lt;h2&gt;Possible&amp;nbsp;solutions&lt;/h2&gt;
&lt;p&gt;After detecting the &lt;span class="caps"&gt;UB&lt;/span&gt; source, the question is how to fix it?
Well, as discussed previously, it&amp;#8217;s the responsibility of developers to avoid
&lt;span class="caps"&gt;UB&lt;/span&gt; in their code. Ideally, this means to ensure that &lt;span class="caps"&gt;UB&lt;/span&gt; never happens for &lt;em&gt;any&lt;/em&gt; program input.
In practice, however, we need to avoid unnecessary checks by ensuring that &lt;span class="caps"&gt;UB&lt;/span&gt; does not happen
on &amp;#8220;expected&amp;#8221; inputs - at&amp;nbsp;least.&lt;/p&gt;
&lt;p&gt;Translating this to our &lt;span class="caps"&gt;UB&lt;/span&gt; case, we can either (1) insert nullptr checks &lt;em&gt;before&lt;/em&gt; calling
method &lt;code&gt;as&lt;/code&gt;, (2) simply replace calls to method &lt;code&gt;as&lt;/code&gt; with dynamic casts,
or (3) convert method &lt;code&gt;as&lt;/code&gt; to be static. The last option requires the least amount
of change to the existing code which is a desirable property. Also,
it has the advantage of maintaining the type safety of the original code.
That is, method &lt;code&gt;as&lt;/code&gt; shall accept only class &lt;code&gt;Base&lt;/code&gt; or one of its derived classes as input.
The final code after applying solution (3) will look something like the&amp;nbsp;following,&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fst_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;snd_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fst_ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;snd_ptr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;snd_ptr&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Finally, building portable and future-proof software in C/C++ requires paying
attention to &lt;span class="caps"&gt;UB&lt;/span&gt; in your code. The availability of excellent tool support in the
form of &lt;span class="caps"&gt;UB&lt;/span&gt; sanitizers, among others, has made catching &lt;span class="caps"&gt;UB&lt;/span&gt; significantly easier.
It&amp;#8217;s recommended to regularly activate &lt;span class="caps"&gt;UB&lt;/span&gt; sanitizers on your code
in order to catch potential issues early and more&amp;nbsp;often.&lt;/p&gt;
&lt;/div&gt;
</content><category term="c++"></category><category term="gcc"></category><category term="undefined behavior"></category></entry><entry><title>Floating-point satisfiability as global optimization</title><link href="https://blog.formallyapplied.com/2017/05/gosat-faq/" rel="alternate"></link><published>2017-05-10T10:20:00+02:00</published><updated>2017-05-10T10:20:00+02:00</updated><author><name>Ammar Ben Khadra</name></author><id>tag:blog.formallyapplied.com,2017-05-10:/2017/05/gosat-faq/</id><summary type="html">&lt;p class="first last"&gt;Solving &lt;span class="caps"&gt;SMT&lt;/span&gt; formulas involving the theory of floating-pointing arithmetic (&lt;span class="caps"&gt;FPA&lt;/span&gt;)
can be encountered in several domains including symbolic execution and program synthesis.
Unfortunately, &lt;span class="caps"&gt;SMT&lt;/span&gt; solvers which support &lt;span class="caps"&gt;FPA&lt;/span&gt; often struggle
trying to satisfy&amp;nbsp;&amp;#8230;&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Solving &lt;span class="caps"&gt;SMT&lt;/span&gt; formulas involving the theory of floating-pointing arithmetic (&lt;span class="caps"&gt;FPA&lt;/span&gt;)
can be required in several domains including symbolic execution, test generation,
and program synthesis. Unfortunately, &lt;span class="caps"&gt;SMT&lt;/span&gt; solvers often struggle
trying to satisfy given &lt;span class="caps"&gt;FPA&lt;/span&gt; queries. Additionally, commonly used non-linear functions,
e.g. trigonometric, remain unsupported.
This leaves tool developers with limited options like employing uninterpreted functions
which can be tricky or work around the issue by ignoring &lt;span class="caps"&gt;FPA&lt;/span&gt;&amp;nbsp;altogether.&lt;/p&gt;
&lt;p&gt;Recently, I&amp;#8217;ve been exploring &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Global_optimization"&gt;global optimization&lt;/a&gt;
as an alternative option for tackling this problem. This approach is unconventional
in the sense that it departs away from the known and trusted &lt;span class="caps"&gt;DPLL&lt;/span&gt;(T) framework.
This work is based on the ideas published in the &lt;a class="reference external" href="http://dx.doi.org/10.1007/978-3-319-41540-6_11"&gt;XSat&lt;/a&gt;
paper by Fu et al. (&lt;span class="caps"&gt;CAV&lt;/span&gt;&amp;#8216;16). Our results are discussed in this &lt;a class="reference external" href="/docs/gosat.pdf"&gt;report&lt;/a&gt;.
This work is implemented in the &lt;span class="caps"&gt;SMT&lt;/span&gt; solver &lt;em&gt;goSAT&lt;/em&gt; which is publicly &lt;a class="reference external" href="https://github.com/abenkhadra/gosat"&gt;available&lt;/a&gt;.
We provide in the following an appendix to our report in Q&amp;amp;A format.
I find this format particularly useful for providing quick takeaways
to interested readers.
Additionally, it can help in clearing possible&amp;nbsp;misunderstandings.&lt;/p&gt;
&lt;div class="section" id="appendix"&gt;
&lt;h2&gt;Appendix&lt;/h2&gt;
&lt;blockquote class="pull-quote"&gt;
&lt;strong&gt;Note&lt;/strong&gt;. This appendix was edited in collaboration with Dominik Stoffel and Wolfgang Kunz.
Errors and omissions are mine.&lt;/blockquote&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;Q:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;em&gt;Evaluations results demonstrate that MathSat still compares favorably in terms of &lt;span class="caps"&gt;SAT&lt;/span&gt; instances solved.
Why do we need exploring alternatives to conventional solvers?&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;A:&lt;/th&gt;&lt;td class="field-body"&gt;Our experimental evaluation considered only one set of &lt;span class="caps"&gt;FPA&lt;/span&gt; benchmarks.
Hence, it&amp;#8217;s still early to draw general conclusions.
Actually, our main target was assessing the potential of different &lt;span class="caps"&gt;GO&lt;/span&gt;
algorithms rather than comparing with MathSAT. Also, the merit of goSAT
is that it can, in principle, reason about any executable function, e.g., trigonometric
functions, which is not possible in MathSat. Further, extending MathSat to
Optimization-Modulo-Theory (&lt;span class="caps"&gt;OMT&lt;/span&gt;) over &lt;span class="caps"&gt;FPA&lt;/span&gt; will require implementing &lt;span class="caps"&gt;GO&lt;/span&gt; algorithms
similar to the ones we discussed. Finally, goSAT has a significant advantage in
terms of query time and used memory despite the fact that it&amp;#8217;s still at an early stage.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;Q:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;em&gt;Wouldn&amp;#8217;t compiler optimizations affect the soundness of the results?&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;A:&lt;/th&gt;&lt;td class="field-body"&gt;goSAT emits a restricted &lt;span class="caps"&gt;IR&lt;/span&gt; subset that doesn&amp;#8217;t have common features
like loops and heap allocations. Also, compiler optimizations are restricted to only one
function representing &lt;span class="math"&gt;\(\mathcal{G}(\vec{x})\)&lt;/span&gt;, i.e. intra-procedural optimizations only.
Works on compiler validation e.g. &lt;span class="caps"&gt;EMI&lt;/span&gt; &lt;a class="citation-reference" href="#pldi14" id="id1"&gt;[&lt;span class="caps"&gt;PLDI14&lt;/span&gt;]&lt;/a&gt; and CSmith &lt;a class="citation-reference" href="#pldi11" id="id2"&gt;[&lt;span class="caps"&gt;PLDI11&lt;/span&gt;]&lt;/a&gt;, demonstrate that
compiler &lt;em&gt;miscompilation&lt;/em&gt; bugs generally require code with more complex features.
Additionally, goSAT is incomplete when stochastic &lt;span class="caps"&gt;GO&lt;/span&gt; algorithms are applied.
However, it is sound w.r.t. &lt;span class="caps"&gt;SAT&lt;/span&gt; results.
&lt;span class="caps"&gt;SAT&lt;/span&gt; results are easy to validate externally using a simple evaluation.
We implemented this feature in goSAT and, so far, did not encounter invalid results.
Consequently, we do not consider potential compiler bugs to be a serious drawback.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;Q:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;em&gt;What are the contributions of goSAT over XSat?&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;A:&lt;/th&gt;&lt;td class="field-body"&gt;We provide several contributions over XSat.
First, XSat discussed one stochastic &lt;span class="caps"&gt;GO&lt;/span&gt; algorithm (&lt;span class="caps"&gt;MCMC&lt;/span&gt; sampling) and used Scipy as backend
in the experimentation. Scipy supports only one &lt;span class="caps"&gt;GO&lt;/span&gt; algorithm, namely, Basin Hopping.
In comparison, we provide a design-space exploration of different algorithms and backends, e.g., NLopt and IpOpt.
We evaluated four stochastic algorithms and one deterministic algorithm.
Second, our tool, goSAT, is publicly available while XSat is not public.
Third, with &lt;em&gt;&lt;span class="caps"&gt;BH&lt;/span&gt; solver&lt;/em&gt; we provide an open re-implementation of XSat with the same optimization parameters,
as provided to us by the XSat authors.
Fourth, goSAT is more portable compared to XSat since it uses CTypes for &lt;span class="caps"&gt;FFI&lt;/span&gt; instead of C extensions for Python.
Despite this, solving time of both tools is still comparable.
Fifth, we highlighted equations (9-11) which were overlooked in XSat despite being necessary for proving soundness.
Sixth, based on Figure 2, we made the observation that the regularity of generated functions is essential
to making goSAT work in practice.
Finally, XSat requires a manual setup to get working.
In contrast, goSAT is an integrated tool featuring &lt;span class="caps"&gt;JIT&lt;/span&gt; compilation of &lt;span class="caps"&gt;SMT&lt;/span&gt; formulas.
To our knowledge, we are the first to implement this in the context of &lt;span class="caps"&gt;SMT&lt;/span&gt; solving.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;Q:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;em&gt;&lt;span class="caps"&gt;BH&lt;/span&gt; and &lt;span class="caps"&gt;NL&lt;/span&gt; solvers only work if given a compiled shared library as &amp;#8220;input&amp;#8221;.
One would typically expect an &lt;span class="caps"&gt;SMT&lt;/span&gt; formula to be given as input instead?&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;A:&lt;/th&gt;&lt;td class="field-body"&gt;In code generation mode, goSAT generates C code (like XSat) that corresponds
to the given input formula(s). This code needs
to be compiled and given as input to &lt;span class="caps"&gt;BH&lt;/span&gt; or &lt;span class="caps"&gt;NL&lt;/span&gt; solvers. Additionally, goSAT can
solve &lt;span class="caps"&gt;SMT&lt;/span&gt; formulas directly. This is an extension over XSat and a key contribution.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;Q:&lt;/th&gt;&lt;td class="field-body"&gt;&lt;em&gt;Can goSAT provide stable results after multiple runs on the same formula?&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;A:&lt;/th&gt;&lt;td class="field-body"&gt;With stochastic search, a certain degree of instability is unavoidable.
In our experiments, however, we experienced stable results with the majority
of input formulas. For example, applying &lt;code&gt;CRS2&lt;/code&gt; algorithm to the 214 instances in the griggio benchmarks,
we found only two instances, namely, &lt;code&gt;sqrt_c_2&lt;/code&gt; and &lt;code&gt;sqrt_c_5&lt;/code&gt;, to
lead to what can be considered unstable results.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;span class="raw-html"&gt;&lt;hr/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!-- comment rubric:: References --&gt;
&lt;table class="docutils citation" frame="void" id="pldi14" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[&lt;span class="caps"&gt;PLDI14&lt;/span&gt;]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;V.&lt;/tt&gt; Le, M. Afshari, and Z. Su, “Compiler validation via equivalence modulo inputs,” in Proceedings of the 35th Conference on Programming Languages Design and Implementation (&lt;span class="caps"&gt;PLDI&lt;/span&gt;’14), 2014, pp. 216–226.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="pldi11" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[&lt;span class="caps"&gt;PLDI11&lt;/span&gt;]&lt;/td&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;X.&lt;/tt&gt; Yang, Y. Chen, E. Eide, and J. Regehr, “Finding and understanding bugs in C compilers,” in Proceedings of the 32nd conference on Programming language design and implementation (&lt;span class="caps"&gt;PLDI&lt;/span&gt;’11), 2011, pp. 283–294.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="smt"></category><category term="floating-point"></category></entry><entry><title>Building this blog</title><link href="https://blog.formallyapplied.com/2017/05/building-this-blog/" rel="alternate"></link><published>2017-05-04T10:20:00+02:00</published><updated>2017-05-10T18:40:00+02:00</updated><author><name>Ammar Ben Khadra</name></author><id>tag:blog.formallyapplied.com,2017-05-04:/2017/05/building-this-blog/</id><summary type="html">&lt;p class="first last"&gt;Details about the tools and services used in building this blog. Also, some discussion
about the design rationale behind&amp;nbsp;it.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="in-a-nutshell"&gt;
&lt;h2&gt;In a&amp;nbsp;nutshell&lt;/h2&gt;
&lt;p&gt;This blog is powered by &lt;a class="reference external" href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt; using
&lt;a class="reference external" href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3"&gt;pelican-bootstrap3&lt;/a&gt;
theme. It&amp;#8217;s hosted on &lt;a class="reference external" href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt;.  Content distribution
and &lt;span class="caps"&gt;TLS&lt;/span&gt; encryption are powered by &lt;a class="reference external" href="https://www.cloudflare.com"&gt;CloudFlare&lt;/a&gt;.
In terms of cost, I had to pay only for the domain name registration.
A template of this blog is provided &lt;a class="reference external" href="https://github.com/abenkhadra/formallyapplied.template"&gt;here&lt;/a&gt;.
Basically, you only need to &lt;a class="reference external" href="http://docs.getpelican.com/en/3.7.1/install.html"&gt;install pelican&lt;/a&gt;
and you should be able of getting the template up and running in a matter of&amp;nbsp;minutes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="design-options"&gt;
&lt;h2&gt;Design&amp;nbsp;options&lt;/h2&gt;
&lt;p&gt;If you are interested in the alternative options considered when building this
blog then please read&amp;nbsp;on.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Static or dynamic blog&lt;/strong&gt;. This decision effectively means choosing between
&lt;a class="reference external" href="https://www.wordpress.com"&gt;Wordpress&lt;/a&gt; and a Static Site Generator (&lt;span class="caps"&gt;SSG&lt;/span&gt;). I won&amp;#8217;t
delve into a detailed comparison here. Quick googling should give you a sufficient idea.
Bottom line is that if you have a limited set of requirements - similar to my case -
then I recommend going for a static website.
Basically, it allows you to focus on your content and largely forget about
issues related to maintenance, security, and&amp;nbsp;performance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Choosing an &lt;span class="caps"&gt;SSG&lt;/span&gt;&lt;/strong&gt;. There are plenty of SSGs around on &lt;a class="reference external" href="https://www.staticgen.com"&gt;staticgen&lt;/a&gt;.
What ended up on my shortlist are Jekyll, Hugo, and Pelican. Jekyll is unquestionably
the most popular and is the one endorsed by GitHub. Also,
I read some nice things about Hugo particularly regarding its speed. However, I haven&amp;#8217;t
tried any of them, to be honest, and went directly for Pelican due to these reasons;
First, it is written in Python. I&amp;#8217;m learning Python already and this helps
me have more consolidation around its ecosystem. Second, Pelican comes with native
support for restructuredText which has several
&lt;a class="reference external" href="http://eli.thegreenplace.net/2017/restructuredtext-vs-markdown-for-technical-documentation/"&gt;advantages&lt;/a&gt;
over&amp;nbsp;Markdown.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Blog theme&lt;/strong&gt;. Fortunately, Pelican has a lot of &lt;a class="reference external" href="http://www.pelicanthemes.com/"&gt;themes&lt;/a&gt;
to choose from. I ended up choosing &lt;em&gt;pelican-bootstrap3&lt;/em&gt;. This theme supports
Booststrap (that is easy to guess!) and its corresponding &lt;a class="reference external" href="https://bootswatch.com/"&gt;bootswatch&lt;/a&gt; themes.
Then, I customized my own bootswatch sub-theme which is named &amp;#8220;formally&amp;#8221; based on the Sandstone sub-theme.
In this regard, I tried to follow some rules like the ones found
&lt;a class="reference external" href="https://spark.adobe.com/blog/2017/01/30/13-rules-to-help-you-stop-making-bad-font-choices/"&gt;here&lt;/a&gt;
and &lt;a class="reference external" href="https://designschool.canva.com/blog/design-rules//"&gt;here&lt;/a&gt;.
These rules seem to summarize sensible&amp;nbsp;wisdom.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, in order to apply your own customization to the provided template,
consider using &lt;a class="reference external" href="https://developers.google.com/web/tools/setup/setup-workflow"&gt;Map to Network Resource&lt;/a&gt;
which is a feature available in Chrome. This feature helps
you iterate quickly and thus saves you a lot of time in the&amp;nbsp;process&lt;/p&gt;
&lt;/div&gt;
</content><category term="blogging"></category></entry></feed>