<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Formally Applied</title><link>https://blog.formallyapplied.com/</link><description></description><lastBuildDate>Tue, 07 Nov 2017 10:20:00 +0100</lastBuildDate><item><title>An introduction to approximate computing</title><link>https://blog.formallyapplied.com/2017/11/approx-intro/</link><description>&lt;p class="first last"&gt;Approximate computing is a wide spectrum of techniques that relax
accuracy of computations in order to improve performance, energy, and/or other
metric of merit. In this article, I&amp;#8217;ll try to provide a structured introduction
to this research&amp;nbsp;area.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Ammar Ben Khadra</dc:creator><pubDate>Tue, 07 Nov 2017 10:20:00 +0100</pubDate><guid isPermaLink="false">tag:blog.formallyapplied.com,2017-11-07:/2017/11/approx-intro/</guid><category>research</category><category>approximate computing</category><category>reliability</category></item><item><title>Undefined behavior in the wild</title><link>https://blog.formallyapplied.com/2017/05/ub-in-wild/</link><description>&lt;p class="first last"&gt;So I was hacking an open source C++ project. The project builds
using gcc v5.4 and runs without problems. Then, I grabbed gcc v6.2 to see
how much performance improvement can be gained. Surprisingly, the program segfaulted&amp;nbsp;&amp;#8230;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Ammar Ben Khadra</dc:creator><pubDate>Thu, 25 May 2017 10:20:00 +0200</pubDate><guid isPermaLink="false">tag:blog.formallyapplied.com,2017-05-25:/2017/05/ub-in-wild/</guid><category>programming</category><category>c++</category><category>gcc</category><category>undefined behavior</category></item><item><title>Floating-point satisfiability as global optimization</title><link>https://blog.formallyapplied.com/2017/05/gosat-faq/</link><description>&lt;p class="first last"&gt;Solving &lt;span class="caps"&gt;SMT&lt;/span&gt; formulas involving the theory of floating-pointing arithmetic (&lt;span class="caps"&gt;FPA&lt;/span&gt;)
can be encountered in several domains including symbolic execution and program synthesis.
Unfortunately, &lt;span class="caps"&gt;SMT&lt;/span&gt; solvers which support &lt;span class="caps"&gt;FPA&lt;/span&gt; often struggle
trying to satisfy&amp;nbsp;&amp;#8230;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Ammar Ben Khadra</dc:creator><pubDate>Wed, 10 May 2017 10:20:00 +0200</pubDate><guid isPermaLink="false">tag:blog.formallyapplied.com,2017-05-10:/2017/05/gosat-faq/</guid><category>research</category><category>smt</category><category>floating-point</category></item><item><title>Building this blog</title><link>https://blog.formallyapplied.com/2017/05/building-this-blog/</link><description>&lt;p class="first last"&gt;Details about the tools and services used in building this blog. Also, some discussion
about the design rationale behind&amp;nbsp;it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Ammar Ben Khadra</dc:creator><pubDate>Thu, 04 May 2017 10:20:00 +0200</pubDate><guid isPermaLink="false">tag:blog.formallyapplied.com,2017-05-04:/2017/05/building-this-blog/</guid><category>misc</category><category>blogging</category></item></channel></rss>